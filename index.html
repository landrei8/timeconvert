<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>World Time Converter</title>
<link href="https://fonts.googleapis.com/css2?family=DM+Mono:wght@300;400;500&family=Fraunces:ital,opsz,wght@0,9..144,300;0,9..144,700;1,9..144,400&display=swap" rel="stylesheet">
<style>
  :root {
    --bg: #0e0e12;
    --surface: #16161d;
    --surface2: #1e1e28;
    --border: #2a2a38;
    --accent: #c8f04e;
    --accent2: #f04e7a;
    --text: #e8e8f0;
    --muted: #6868a0;
    --cell-w: 36px;
  }
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'DM Mono', monospace;
    min-height: 100vh;
  }

  header {
    padding: 1.4rem 2rem 1rem;
    display: flex; align-items: center; gap: 1rem;
    border-bottom: 1px solid var(--border);
  }
  header h1 {
    font-family: 'Fraunces', serif; font-size: 1.4rem;
    font-weight: 300; color: var(--accent); letter-spacing: -0.02em;
  }
  header span { font-size: 0.65rem; color: var(--muted); letter-spacing: 0.15em; text-transform: uppercase; }

  .date-nav { display: flex; align-items: center; gap: 0.4rem; margin-left: auto; }
  .date-btn {
    background: none; border: 1px solid var(--border); color: var(--muted);
    padding: 0.28rem 0.55rem; border-radius: 4px; cursor: pointer;
    font-family: 'DM Mono', monospace; font-size: 0.7rem; transition: all 0.15s;
  }
  .date-btn:hover { border-color: var(--accent); color: var(--accent); }
  .date-btn.active { background: var(--accent); color: var(--bg); border-color: var(--accent); font-weight: 500; }

  .main { padding: 1.2rem 2rem; }
  .top-bar { display: flex; align-items: center; gap: 1rem; margin-bottom: 1rem; flex-wrap: wrap; }

  .search-wrap { position: relative; flex: 0 0 300px; }
  .search-wrap input {
    width: 100%; background: var(--surface); border: 1px solid var(--border);
    color: var(--text); padding: 0.55rem 0.75rem 0.55rem 2rem;
    border-radius: 6px; font-family: 'DM Mono', monospace; font-size: 0.75rem;
    outline: none; transition: border-color 0.2s;
  }
  .search-wrap input:focus { border-color: var(--accent); }
  .search-wrap input::placeholder { color: var(--muted); }
  .search-icon { position: absolute; left: 0.55rem; top: 50%; transform: translateY(-50%); color: var(--muted); pointer-events: none; font-size: 0.8rem; }
  .dropdown {
    position: absolute; top: calc(100% + 4px); left: 0; width: 100%;
    background: var(--surface2); border: 1px solid var(--border);
    border-radius: 6px; z-index: 200; max-height: 260px; overflow-y: auto; display: none;
  }
  .dropdown.open { display: block; }
  .dropdown-item {
    padding: 0.5rem 0.75rem; cursor: pointer; font-size: 0.73rem;
    display: flex; justify-content: space-between; align-items: center; transition: background 0.1s;
  }
  .dropdown-item:hover { background: rgba(200,240,78,0.1); }
  .dropdown-item .tz-label { color: var(--muted); font-size: 0.65rem; }
  .dropdown-item .tz-type { font-size: 0.58rem; padding: 0.05rem 0.3rem; border-radius: 3px; background: var(--surface); border: 1px solid var(--border); color: var(--muted); margin-left: 0.4rem; }
  .dropdown-item .tz-type.tz-zone { color: #74e09c; border-color: rgba(116,224,156,0.3); }
  .dropdown-sep { padding: 0.22rem 0.75rem; font-size: 0.58rem; color: var(--muted); background: var(--surface); text-transform: uppercase; letter-spacing: 0.1em; border-top: 1px solid var(--border); }

  .range-info {
    flex: 1; background: var(--surface); border: 1px solid var(--border);
    border-radius: 6px; padding: 0.5rem 1rem; font-size: 0.72rem;
    color: var(--muted); display: flex; align-items: center; gap: 1rem; flex-wrap: wrap;
  }
  .range-info .duration { color: var(--accent); font-weight: 500; font-size: 0.85rem; }
  .range-info .city-time strong { color: var(--accent); }

  .legend { display: flex; align-items: center; gap: 0.8rem; margin-left: auto; }
  .legend-item { display: flex; align-items: center; gap: 0.3rem; font-size: 0.62rem; color: var(--muted); text-transform: uppercase; letter-spacing: 0.1em; }
  .legend-dot { width: 9px; height: 9px; border-radius: 2px; }
  .legend-dot.work { background: rgba(200,240,78,0.22); border: 1px solid rgba(200,240,78,0.4); }
  .legend-dot.sleep { background: rgba(240,78,122,0.15); border: 1px solid rgba(240,78,122,0.3); }

  .clocks-area { display: flex; flex-direction: column; gap: 2px; }

  .clock-row {
    display: grid; grid-template-columns: 210px 1fr;
    align-items: stretch; background: var(--surface);
    border: 1px solid var(--border); border-radius: 8px; overflow: hidden;
    animation: rowIn 0.25s ease;
  }
  @keyframes rowIn { from { opacity:0; transform:translateY(-6px); } to { opacity:1; transform:translateY(0); } }

  .city-info {
    padding: 0.85rem 1rem; display: flex; flex-direction: column;
    justify-content: center; border-right: 1px solid var(--border);
    gap: 0.1rem; position: relative; min-height: 82px;
  }
  .city-name-big {
    font-family: 'Fraunces', serif; font-size: 1rem; font-weight: 700;
    display: flex; align-items: center; gap: 0.35rem;
  }
  .tz-tag {
    font-family: 'DM Mono', monospace; font-size: 0.58rem;
    background: var(--surface2); border: 1px solid var(--border);
    padding: 0.08rem 0.28rem; border-radius: 3px; color: var(--muted); font-weight: 400;
  }
  .country-label { font-size: 0.62rem; color: var(--muted); text-transform: uppercase; letter-spacing: 0.08em; }
  .range-time-label { font-size: 0.78rem; color: var(--text); margin-top: 0.2rem; min-height: 1.1rem; }
  .offset-badge { font-size: 0.6rem; color: var(--muted); }
  .offset-badge.pos { color: #74e09c; }
  .offset-badge.neg { color: var(--accent2); }
  .home-icon { position: absolute; right: 0.7rem; top: 0.5rem; font-size: 0.65rem; color: var(--accent); opacity: 0.5; }
  .remove-btn {
    background: none; border: none; color: var(--muted); cursor: pointer;
    font-size: 0.75rem; position: absolute; right: 0.7rem; bottom: 0.5rem;
    opacity: 0; transition: opacity 0.2s, color 0.2s;
  }
  .clock-row:hover .remove-btn { opacity: 1; }
  .remove-btn:hover { color: var(--accent2); }

  .timeline-wrap { overflow-x: auto; position: relative; scrollbar-width: none; }
  .timeline-wrap::-webkit-scrollbar { display: none; }

  .timeline {
    display: flex; align-items: stretch;
    position: relative; height: 82px;
  }

  .hour-cell {
    flex: 0 0 var(--cell-w); width: var(--cell-w); display: flex;
    flex-direction: column; align-items: center; justify-content: center;
    border-right: 1px solid rgba(255,255,255,0.03);
    gap: 0.18rem; position: relative; transition: background 0.08s;
    cursor: crosshair; user-select: none;
  }
  .hour-cell.work { background: rgba(200,240,78,0.08); }
  .hour-cell.sleep { background: rgba(240,78,122,0.07); }

  .hour-num { font-size: 0.62rem; font-weight: 500; color: var(--text); pointer-events: none; }
  .hour-cell.sleep .hour-num { color: var(--muted); }
  .ampm-tiny { font-size: 0.46rem; color: var(--muted); pointer-events: none; }
  .hour-cell.half .hour-num { font-size: 0.46rem; color: var(--muted); opacity: 0.5; }
  .hour-cell.half .ampm-tiny { display: none; }

  /* Selection overlay */
  .sel-overlay {
    position: absolute; top: 0; bottom: 0;
    background: rgba(200,240,78,0.15);
    border: 2px solid var(--accent);
    pointer-events: none; z-index: 5;
    border-radius: 2px;
  }

  /* Drag handles */
  .drag-handle {
    position: absolute; top: 0; bottom: 0; width: 12px;
    cursor: ew-resize; z-index: 10; pointer-events: all;
    display: flex; align-items: center; justify-content: center;
  }
  .drag-handle::after {
    content: ''; display: block;
    width: 3px; height: 28px;
    background: var(--accent); border-radius: 2px;
    box-shadow: 0 0 6px var(--accent);
  }
  .drag-handle.left { left: -6px; }
  .drag-handle.right { right: -6px; }

  .empty-state { text-align: center; padding: 3rem 2rem; color: var(--muted); font-size: 0.78rem; }
  .empty-state .big { font-family: 'Fraunces', serif; font-size: 2.5rem; color: var(--border); margin-bottom: 0.5rem; }
</style>
</head>
<body>

<header>
  <h1>World Time 1.0</h1>
  <span>Convert timezones easily</span>
  <div class="date-nav" id="dateNav"></div>
</header>

<div class="main">
  <div class="top-bar">
    <div class="search-wrap">
      <span class="search-icon">⊕</span>
      <input type="text" id="citySearch" placeholder="City, timezone (EET, UTC+2, Asia/Tokyo)…" autocomplete="off">
      <div class="dropdown" id="dropdown"></div>
    </div>
    <div class="range-info" id="rangeInfo">
      <span>Drag across the time bar to select a range</span>
      <div class="legend">
        <div class="legend-item"><div class="legend-dot work"></div>Business</div>
        <div class="legend-item"><div class="legend-dot sleep"></div>Night</div>
      </div>
    </div>
  </div>
  <div class="clocks-area" id="clocksArea">
    <div class="empty-state"><div class="big">+</div>Search for a city above to get started</div>
  </div>
</div>

<script>
const CITIES = [
  { name:'New York', country:'United States', tz:'America/New_York', abbr:'EST' },
  { name:'Los Angeles', country:'United States', tz:'America/Los_Angeles', abbr:'PST' },
  { name:'Chicago', country:'United States', tz:'America/Chicago', abbr:'CST' },
  { name:'Denver', country:'United States', tz:'America/Denver', abbr:'MST' },
  { name:'Seattle', country:'United States', tz:'America/Los_Angeles', abbr:'PST' },
  { name:'Miami', country:'United States', tz:'America/New_York', abbr:'EST' },
  { name:'Boston', country:'United States', tz:'America/New_York', abbr:'EST' },
  { name:'San Francisco', country:'United States', tz:'America/Los_Angeles', abbr:'PST' },
  { name:'Houston', country:'United States', tz:'America/Chicago', abbr:'CST' },
  { name:'Phoenix', country:'United States', tz:'America/Phoenix', abbr:'MST' },
  { name:'London', country:'United Kingdom', tz:'Europe/London', abbr:'GMT' },
  { name:'Paris', country:'France', tz:'Europe/Paris', abbr:'CET' },
  { name:'Berlin', country:'Germany', tz:'Europe/Berlin', abbr:'CET' },
  { name:'Madrid', country:'Spain', tz:'Europe/Madrid', abbr:'CET' },
  { name:'Rome', country:'Italy', tz:'Europe/Rome', abbr:'CET' },
  { name:'Amsterdam', country:'Netherlands', tz:'Europe/Amsterdam', abbr:'CET' },
  { name:'Brussels', country:'Belgium', tz:'Europe/Brussels', abbr:'CET' },
  { name:'Vienna', country:'Austria', tz:'Europe/Vienna', abbr:'CET' },
  { name:'Zurich', country:'Switzerland', tz:'Europe/Zurich', abbr:'CET' },
  { name:'Stockholm', country:'Sweden', tz:'Europe/Stockholm', abbr:'CET' },
  { name:'Oslo', country:'Norway', tz:'Europe/Oslo', abbr:'CET' },
  { name:'Copenhagen', country:'Denmark', tz:'Europe/Copenhagen', abbr:'CET' },
  { name:'Helsinki', country:'Finland', tz:'Europe/Helsinki', abbr:'EET' },
  { name:'Warsaw', country:'Poland', tz:'Europe/Warsaw', abbr:'CET' },
  { name:'Prague', country:'Czech Republic', tz:'Europe/Prague', abbr:'CET' },
  { name:'Budapest', country:'Hungary', tz:'Europe/Budapest', abbr:'CET' },
  { name:'Bucharest', country:'Romania', tz:'Europe/Bucharest', abbr:'EET' },
  { name:'Sofia', country:'Bulgaria', tz:'Europe/Sofia', abbr:'EET' },
  { name:'Athens', country:'Greece', tz:'Europe/Athens', abbr:'EET' },
  { name:'Istanbul', country:'Turkey', tz:'Europe/Istanbul', abbr:'TRT' },
  { name:'Moscow', country:'Russia', tz:'Europe/Moscow', abbr:'MSK' },
  { name:'Kyiv', country:'Ukraine', tz:'Europe/Kiev', abbr:'EET' },
  { name:'Lisbon', country:'Portugal', tz:'Europe/Lisbon', abbr:'WET' },
  { name:'Dubai', country:'UAE', tz:'Asia/Dubai', abbr:'GST' },
  { name:'Riyadh', country:'Saudi Arabia', tz:'Asia/Riyadh', abbr:'AST' },
  { name:'Mumbai', country:'India', tz:'Asia/Kolkata', abbr:'IST' },
  { name:'Delhi', country:'India', tz:'Asia/Kolkata', abbr:'IST' },
  { name:'Bangalore', country:'India', tz:'Asia/Kolkata', abbr:'IST' },
  { name:'Kolkata', country:'India', tz:'Asia/Kolkata', abbr:'IST' },
  { name:'Singapore', country:'Singapore', tz:'Asia/Singapore', abbr:'SGT' },
  { name:'Hong Kong', country:'China', tz:'Asia/Hong_Kong', abbr:'HKT' },
  { name:'Shanghai', country:'China', tz:'Asia/Shanghai', abbr:'CST' },
  { name:'Beijing', country:'China', tz:'Asia/Shanghai', abbr:'CST' },
  { name:'Tokyo', country:'Japan', tz:'Asia/Tokyo', abbr:'JST' },
  { name:'Seoul', country:'South Korea', tz:'Asia/Seoul', abbr:'KST' },
  { name:'Taipei', country:'Taiwan', tz:'Asia/Taipei', abbr:'CST' },
  { name:'Bangkok', country:'Thailand', tz:'Asia/Bangkok', abbr:'ICT' },
  { name:'Jakarta', country:'Indonesia', tz:'Asia/Jakarta', abbr:'WIB' },
  { name:'Kuala Lumpur', country:'Malaysia', tz:'Asia/Kuala_Lumpur', abbr:'MYT' },
  { name:'Karachi', country:'Pakistan', tz:'Asia/Karachi', abbr:'PKT' },
  { name:'Dhaka', country:'Bangladesh', tz:'Asia/Dhaka', abbr:'BST' },
  { name:'Colombo', country:'Sri Lanka', tz:'Asia/Colombo', abbr:'SLST' },
  { name:'Kathmandu', country:'Nepal', tz:'Asia/Kathmandu', abbr:'NPT' },
  { name:'Tehran', country:'Iran', tz:'Asia/Tehran', abbr:'IRST' },
  { name:'Baghdad', country:'Iraq', tz:'Asia/Baghdad', abbr:'AST' },
  { name:'Cairo', country:'Egypt', tz:'Africa/Cairo', abbr:'EET' },
  { name:'Lagos', country:'Nigeria', tz:'Africa/Lagos', abbr:'WAT' },
  { name:'Nairobi', country:'Kenya', tz:'Africa/Nairobi', abbr:'EAT' },
  { name:'Johannesburg', country:'South Africa', tz:'Africa/Johannesburg', abbr:'SAST' },
  { name:'Casablanca', country:'Morocco', tz:'Africa/Casablanca', abbr:'WET' },
  { name:'Sydney', country:'Australia', tz:'Australia/Sydney', abbr:'AEDT' },
  { name:'Melbourne', country:'Australia', tz:'Australia/Melbourne', abbr:'AEDT' },
  { name:'Brisbane', country:'Australia', tz:'Australia/Brisbane', abbr:'AEST' },
  { name:'Perth', country:'Australia', tz:'Australia/Perth', abbr:'AWST' },
  { name:'Auckland', country:'New Zealand', tz:'Pacific/Auckland', abbr:'NZDT' },
  { name:'Toronto', country:'Canada', tz:'America/Toronto', abbr:'EST' },
  { name:'Vancouver', country:'Canada', tz:'America/Vancouver', abbr:'PST' },
  { name:'Montreal', country:'Canada', tz:'America/Montreal', abbr:'EST' },
  { name:'São Paulo', country:'Brazil', tz:'America/Sao_Paulo', abbr:'BRT' },
  { name:'Buenos Aires', country:'Argentina', tz:'America/Argentina/Buenos_Aires', abbr:'ART' },
  { name:'Santiago', country:'Chile', tz:'America/Santiago', abbr:'CLT' },
  { name:'Lima', country:'Peru', tz:'America/Lima', abbr:'PET' },
  { name:'Mexico City', country:'Mexico', tz:'America/Mexico_City', abbr:'CST' },
  { name:'Honolulu', country:'United States', tz:'Pacific/Honolulu', abbr:'HST' },
  { name:'Anchorage', country:'United States', tz:'America/Anchorage', abbr:'AKST' },
];

// ============================================================
// STATE
// ============================================================
let cities = [];
let anchorDay = new Date();
anchorDay.setHours(0, 0, 0, 0);

// selStart / selEnd are slot indices 0-47 (30-min slots) based on first city's local day
let selStart = null;
let selEnd = null;

const CELL_W = 36;
const SLOTS = 48;       // 48 half-hour slots per day
const SLOT_MINS = 30;   // minutes per slot

// ============================================================
// TIMEZONE MATH
// ============================================================

/**
 * The KEY idea: we pick 48 UTC moments that correspond to
 * half-hour slots 0-47 of the *first* city's local calendar day.
 * Every other city then shows what time THEY have at each of those UTC moments.
 * This gives correct timezone conversion automatically.
 */
function getSlotUTCMs() {
  if (!cities.length) return [];
  const tz = cities[0].tz;
  const ymd = anchorDay.toLocaleDateString('en-CA'); // YYYY-MM-DD
  const slots = [];
  for (let s = 0; s < SLOTS; s++) {
    const h = Math.floor(s / 2);
    const m = (s % 2) * 30;
    const localStr = `${ymd}T${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:00`;
    slots.push(localToUTC(localStr, tz));
  }
  return slots;
}

function localToUTC(localISONoZ, tz) {
  // Use the offset at approximately that time
  // We create a UTC date and adjust
  const naive = new Date(localISONoZ + 'Z'); // pretend it's UTC first
  // Format that UTC date in the target tz to get the local representation
  const fmt = new Intl.DateTimeFormat('en-US', {
    timeZone: tz,
    year: 'numeric', month: '2-digit', day: '2-digit',
    hour: '2-digit', minute: '2-digit', second: '2-digit',
    hour12: false
  });
  const parts = fmt.formatToParts(naive);
  const p = {};
  parts.forEach(x => { p[x.type] = x.value; });
  // The "local" time as UTC (wrong)
  const fakeLocal = Date.UTC(+p.year, +p.month - 1, +p.day, +p.hour % 24, +p.minute, +p.second);
  // offset = naive(UTC) - fakeLocal
  const offset = naive.getTime() - fakeLocal;
  // So real UTC = naive + offset... wait, let me think:
  // naive = localISONoZ treated as UTC
  // fakeLocal = what tz displays for naive
  // We want: find UTC such that tz displays localISONoZ
  // tz(UTC) = localISONoZ => UTC = localISONoZ_as_ms + offset_east
  // offset_east = UTC - local => offset = naive - fakeLocal (since naive is the "UTC" input and fakeLocal is the tz output)
  // So: UTC_we_want = naive_local_as_utc + offset = naive + (naive - fakeLocal) ... no
  // Actually: offset_east_ms = naive.getTime() - fakeLocal  [this is UTC_input - local_output = -offset_west]
  // We want UTC such that UTC - offset_east = localISONoZ_as_ms
  // UTC = localISONoZ_as_ms + offset_east = naive.getTime() + (naive.getTime() - fakeLocal) ... no
  // 
  // Simpler: offset_east = naive - fakeLocal
  // We want UTC where local = naive: UTC_target = naive_as_utc_ms - offset_east  
  // But offset_east computed at naive may differ from at UTC_target (DST)
  // For most cases one iteration suffices:
  const utcApprox = naive.getTime() - offset;
  return utcApprox;
}

function getHourMinInTZ(utcMs, tz) {
  const d = new Date(utcMs);
  const str = d.toLocaleString('en-US', {
    timeZone: tz, hour: '2-digit', minute: '2-digit', hour12: false
  });
  const [h, m] = str.split(':').map(Number);
  return { hour: h % 24, minute: m };
}

function getDateInTZ(utcMs, tz) {
  return new Date(utcMs).toLocaleDateString('en-US', {
    timeZone: tz, weekday: 'short', month: 'short', day: 'numeric'
  });
}

function fmt12plain(h, m) {
  const ampm = h < 12 ? 'am' : 'pm';
  const h12 = h % 12 || 12;
  return `${h12}:${String(m).padStart(2, '0')}${ampm}`;
}

function getOffsetLabel(cityTz) {
  // Compare UTC offset between first city and this city right now
  const nowMs = Date.now();
  const h0 = getHourMinInTZ(nowMs, cities[0].tz);
  const hN = getHourMinInTZ(nowMs, cityTz);
  let diffMin = (hN.hour * 60 + hN.minute) - (h0.hour * 60 + h0.minute);
  if (diffMin > 12 * 60) diffMin -= 24 * 60;
  if (diffMin < -12 * 60) diffMin += 24 * 60;
  const diffH = diffMin / 60;
  const sign = diffH >= 0 ? '+' : '';
  const cls = diffH > 0 ? 'pos' : diffH < 0 ? 'neg' : '';
  const disp = Number.isInteger(diffH) ? `${sign}${diffH}h` : `${sign}${diffH.toFixed(1).replace('.0','')}h`;
  return `<span class="offset-badge ${cls}">${disp} vs ${cities[0].name}</span>`;
}

// ============================================================
// RENDER
// ============================================================
let slotUTCMs = []; // computed once per render

function render() {
  slotUTCMs = getSlotUTCMs();
  const area = document.getElementById('clocksArea');

  if (!cities.length) {
    area.innerHTML = '<div class="empty-state"><div class="big">+</div>Search for a city above to get started</div>';
    updateRangeInfo();
    return;
  }

  area.innerHTML = '';
  cities.forEach((city, idx) => buildRow(city, idx));
  updateRangeInfo();

  // Sync scroll to current slot of first city
  const nowLocal = getHourMinInTZ(Date.now(), cities[0].tz);
  const nowSlot = nowLocal.hour * 2 + (nowLocal.minute >= 30 ? 1 : 0);
  const scrollTo = Math.max(0, (nowSlot - 3)) * CELL_W;
  document.querySelectorAll('.timeline-wrap').forEach(w => { w.scrollLeft = scrollTo; });

  // Only first row has the drag logic
  const firstTL = document.getElementById('tl_0');
  const firstWrap = document.getElementById('tlwrap_0');
  if (firstTL && firstWrap) setupDrag(firstTL, firstWrap);
}

function buildRow(city, idx) {
  const area = document.getElementById('clocksArea');
  const row = document.createElement('div');
  row.className = 'clock-row';

  // --- Info panel ---
  const info = document.createElement('div');
  info.className = 'city-info';

  if (idx === 0) {
    info.innerHTML += `<span class="home-icon">⌂</span>`;
  } else {
    info.innerHTML += getOffsetLabel(city.tz);
  }

  info.innerHTML += `
    <div class="city-name-big">${city.name} <span class="tz-tag">${city.abbr}</span></div>
    <div class="country-label">${city.country}</div>
  `;

  const rangeDiv = document.createElement('div');
  rangeDiv.className = 'range-time-label';
  rangeDiv.id = `rlabel_${idx}`;
  info.appendChild(rangeDiv);
  updateRangeLabelEl(rangeDiv, idx);

  if (idx > 0) {
    const rb = document.createElement('button');
    rb.className = 'remove-btn';
    rb.textContent = '✕';
    rb.addEventListener('click', e => { e.stopPropagation(); cities.splice(idx, 1); selStart = null; selEnd = null; render(); });
    info.appendChild(rb);
  }

  // --- Timeline ---
  const tlWrap = document.createElement('div');
  tlWrap.className = 'timeline-wrap';
  tlWrap.id = `tlwrap_${idx}`;

  const tl = document.createElement('div');
  tl.className = 'timeline';
  tl.id = `tl_${idx}`;
  tl.style.width = `${SLOTS * CELL_W}px`;

  // Selection overlay
  const overlay = document.createElement('div');
  overlay.className = 'sel-overlay';
  overlay.id = `overlay_${idx}`;
  if (selStart === null) overlay.style.display = 'none';
  else positionOverlay(overlay);

  // Drag handles on first row only (pointer-events on overlay itself off except handles)
  if (idx === 0) {
    const lh = document.createElement('div');
    lh.className = 'drag-handle left';
    lh.id = 'dh-left';
    overlay.appendChild(lh);
    const rh = document.createElement('div');
    rh.className = 'drag-handle right';
    rh.id = 'dh-right';
    overlay.appendChild(rh);
  }

  tl.appendChild(overlay);

  // Half-hour cells (48 slots)
  for (let i = 0; i < SLOTS; i++) {
    const utcMs = slotUTCMs[i];
    const { hour, minute } = getHourMinInTZ(utcMs, city.tz);
    const isHalf = minute === 30;
    const cell = document.createElement('div');
    cell.className = 'hour-cell' + (isHalf ? ' half' : '');
    cell.dataset.slot = i;
    if ((hour >= 9 && hour < 18) || (hour === 18 && minute === 0)) cell.classList.add('work');
    else if (hour < 7 || hour >= 22) cell.classList.add('sleep');
    const h12 = hour % 12 || 12;
    const ampm = hour < 12 ? 'am' : 'pm';
    if (isHalf) {
      cell.innerHTML = `<span class="hour-num">:30</span>`;
    } else {
      cell.innerHTML = `<span class="hour-num">${h12}</span><span class="ampm-tiny">${ampm}</span>`;
    }
    tl.appendChild(cell);
  }

  tlWrap.appendChild(tl);
  row.appendChild(info);
  row.appendChild(tlWrap);
  area.appendChild(row);

  // Sync scroll between rows
  tlWrap.addEventListener('scroll', () => {
    document.querySelectorAll('.timeline-wrap').forEach(w => {
      if (w !== tlWrap) w.scrollLeft = tlWrap.scrollLeft;
    });
  });
}

function positionOverlay(overlay) {
  if (selStart === null || selEnd === null) { overlay.style.display = 'none'; return; }
  const s = Math.min(selStart, selEnd);
  const e = Math.max(selStart, selEnd);
  overlay.style.display = 'block';
  overlay.style.left = `${s * CELL_W}px`;
  overlay.style.width = `${(e - s + 1) * CELL_W}px`;
}

function updateAllOverlays() {
  cities.forEach((_, idx) => {
    const ov = document.getElementById(`overlay_${idx}`);
    if (ov) positionOverlay(ov);
    const el = document.getElementById(`rlabel_${idx}`);
    if (el) updateRangeLabelEl(el, idx);
  });
  updateRangeInfo();
}

function updateRangeLabelEl(el, idx) {
  if (selStart === null || !cities[idx] || !slotUTCMs.length) {
    // Show live clock
    const { hour, minute } = getHourMinInTZ(Date.now(), cities[idx]?.tz || 'UTC');
    const h12 = hour % 12 || 12;
    const ampm = hour < 12 ? 'am' : 'pm';
    el.innerHTML = `<span style="opacity:0.65;font-size:0.72rem">${h12}:${String(minute).padStart(2,'0')} ${ampm} now</span>`;
    return;
  }
  const s = Math.min(selStart, selEnd);
  const e = Math.max(selStart, selEnd);
  const { hour: hs, minute: ms } = getHourMinInTZ(slotUTCMs[s], cities[idx].tz);
  // end = start of slot after last selected
  const endSlotIdx = Math.min(e + 1, SLOTS - 1);
  const { hour: he, minute: me } = getHourMinInTZ(slotUTCMs[endSlotIdx], cities[idx].tz);
  const endH = e < SLOTS - 1 ? he : (he + (me === 30 ? 0 : 1)) % 24;
  const endM = e < SLOTS - 1 ? me : (me + 30) % 60;
  el.innerHTML = `${fmt12plain(hs, ms)}<span style="color:var(--muted);margin:0 4px">–</span>${fmt12plain(endH, endM)}`;
}

function updateRangeInfo() {
  const info = document.getElementById('rangeInfo');
  if (selStart === null || !cities.length || !slotUTCMs.length) {
    info.innerHTML = `<span>Drag across the time bar to select a range</span>
      <div class="legend" style="margin-left:auto">
        <div class="legend-item"><div class="legend-dot work"></div>Business</div>
        <div class="legend-item"><div class="legend-dot sleep"></div>Night</div>
      </div>`;
    return;
  }
  const s = Math.min(selStart, selEnd);
  const e = Math.max(selStart, selEnd);
  const totalMins = (e - s + 1) * SLOT_MINS;
  const durH = Math.floor(totalMins / 60);
  const durM = totalMins % 60;
  const durStr = durH > 0 && durM > 0 ? `${durH}h ${durM}m` : durH > 0 ? `${durH}h` : `${durM}m`;
  let html = `<span class="duration">⏱ ${durStr}</span>`;
  cities.forEach(city => {
    const { hour: hs, minute: ms } = getHourMinInTZ(slotUTCMs[s], city.tz);
    const endSlotIdx = Math.min(e + 1, SLOTS - 1);
    const { hour: he, minute: me } = getHourMinInTZ(slotUTCMs[endSlotIdx], city.tz);
    const endH = e < SLOTS - 1 ? he : (me === 30 ? he : (he + 1) % 24);
    const endM = e < SLOTS - 1 ? me : (me + 30) % 60;
    const date = getDateInTZ(slotUTCMs[s], city.tz);
    html += `<span class="city-time"><strong>${city.name}</strong> ${fmt12plain(hs, ms)}–${fmt12plain(endH, endM)}, ${date}</span>`;
  });
  html += `<div class="legend" style="margin-left:auto">
    <div class="legend-item"><div class="legend-dot work"></div>Business</div>
    <div class="legend-item"><div class="legend-dot sleep"></div>Night</div>
  </div>`;
  info.innerHTML = html;
}

// ============================================================
// DRAG LOGIC
// ============================================================
let isDragging = false;
let dragMode = null; // 'new' | 'left' | 'right' | 'move'
let dragStartClientX = 0;
let dragSavedStart = null;
let dragSavedEnd = null;

function setupDrag(tl, tlWrap) {
  tl.addEventListener('mousedown', onDragStart);
  tl.addEventListener('touchstart', onTouchStart, { passive: false });
}

function onDragStart(e) {
  if (e.button !== 0) return;
  determineDragMode(e.clientX);
  isDragging = true;
  e.preventDefault();
}

function onTouchStart(e) {
  determineDragMode(e.touches[0].clientX);
  isDragging = true;
  e.preventDefault();
}

function determineDragMode(clientX) {
  dragStartClientX = clientX;
  dragSavedStart = selStart !== null ? Math.min(selStart, selEnd) : null;
  dragSavedEnd = selStart !== null ? Math.max(selStart, selEnd) : null;

  const lh = document.getElementById('dh-left');
  const rh = document.getElementById('dh-right');
  const overlay = document.getElementById('overlay_0');

  if (lh) {
    const lr = lh.getBoundingClientRect();
    if (clientX >= lr.left - 8 && clientX <= lr.right + 8) { dragMode = 'left'; return; }
  }
  if (rh) {
    const rr = rh.getBoundingClientRect();
    if (clientX >= rr.left - 8 && clientX <= rr.right + 8) { dragMode = 'right'; return; }
  }
  if (overlay && selStart !== null) {
    const or = overlay.getBoundingClientRect();
    if (clientX >= or.left && clientX <= or.right) { dragMode = 'move'; return; }
  }
  dragMode = 'new';
  const slot = clientXToSlot(clientX);
  selStart = slot;
  selEnd = slot;
  updateAllOverlays();
}

document.addEventListener('mousemove', e => {
  if (!isDragging) return;
  handleDragMove(e.clientX);
});
document.addEventListener('touchmove', e => {
  if (!isDragging) return;
  handleDragMove(e.touches[0].clientX);
  e.preventDefault();
}, { passive: false });

function handleDragMove(clientX) {
  const slot = clientXToSlot(clientX);
  if (dragMode === 'new') {
    selEnd = slot;
  } else if (dragMode === 'left') {
    const fixedEnd = dragSavedEnd;
    selStart = Math.min(slot, fixedEnd);
    selEnd = fixedEnd;
  } else if (dragMode === 'right') {
    const fixedStart = dragSavedStart;
    selStart = fixedStart;
    selEnd = Math.max(slot, fixedStart);
  } else if (dragMode === 'move') {
    const dx = clientX - dragStartClientX;
    const dSlots = Math.round(dx / CELL_W);
    const len = dragSavedEnd - dragSavedStart;
    let ns = Math.max(0, Math.min(SLOTS - 1 - len, dragSavedStart + dSlots));
    selStart = ns;
    selEnd = ns + len;
  }
  updateAllOverlays();
}

document.addEventListener('mouseup', () => { isDragging = false; dragMode = null; });
document.addEventListener('touchend', () => { isDragging = false; dragMode = null; });

function clientXToSlot(clientX) {
  const wrap = document.getElementById('tlwrap_0');
  if (!wrap) return 0;
  const rect = wrap.getBoundingClientRect();
  const x = clientX - rect.left + wrap.scrollLeft;
  return Math.max(0, Math.min(SLOTS - 1, Math.floor(x / CELL_W)));
}

// ============================================================
// DATE NAV
// ============================================================
function buildDateNav() {
  const nav = document.getElementById('dateNav');
  nav.innerHTML = '';
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  for (let i = -1; i <= 4; i++) {
    const d = new Date(today);
    d.setDate(d.getDate() + i);
    const btn = document.createElement('button');
    btn.className = 'date-btn' + (i === 0 ? ' active' : '');
    btn.textContent = i === 0 ? `${d.toLocaleString('en', { month: 'short' })} ${d.getDate()}` : d.getDate();
    btn.dataset.offset = i;
    btn.addEventListener('click', () => {
      document.querySelectorAll('.date-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      const base = new Date();
      base.setDate(base.getDate() + parseInt(btn.dataset.offset));
      base.setHours(0, 0, 0, 0);
      anchorDay = base;
      selStart = null; selEnd = null;
      render();
    });
    nav.appendChild(btn);
  }
}

// ============================================================
// TIMEZONE DATABASE (for direct TZ search)
// ============================================================
const TZ_ZONES = [
  { tz:'UTC', abbr:'UTC', offset:'+00:00', label:'UTC / GMT' },
  { tz:'Europe/London', abbr:'GMT/BST', offset:'+00:00', label:'London Time' },
  { tz:'Europe/Paris', abbr:'CET/CEST', offset:'+01:00', label:'Central European Time' },
  { tz:'Europe/Berlin', abbr:'CET/CEST', offset:'+01:00', label:'Central European Time' },
  { tz:'Europe/Bucharest', abbr:'EET/EEST', offset:'+02:00', label:'Eastern European Time' },
  { tz:'Europe/Helsinki', abbr:'EET/EEST', offset:'+02:00', label:'Eastern European Time' },
  { tz:'Europe/Athens', abbr:'EET/EEST', offset:'+02:00', label:'Eastern European Time' },
  { tz:'Europe/Moscow', abbr:'MSK', offset:'+03:00', label:'Moscow Standard Time' },
  { tz:'Europe/Istanbul', abbr:'TRT', offset:'+03:00', label:'Turkey Time' },
  { tz:'Asia/Dubai', abbr:'GST', offset:'+04:00', label:'Gulf Standard Time' },
  { tz:'Asia/Kolkata', abbr:'IST', offset:'+05:30', label:'India Standard Time' },
  { tz:'Asia/Kathmandu', abbr:'NPT', offset:'+05:45', label:'Nepal Time' },
  { tz:'Asia/Dhaka', abbr:'BST', offset:'+06:00', label:'Bangladesh Standard Time' },
  { tz:'Asia/Bangkok', abbr:'ICT', offset:'+07:00', label:'Indochina Time' },
  { tz:'Asia/Singapore', abbr:'SGT', offset:'+08:00', label:'Singapore Time' },
  { tz:'Asia/Shanghai', abbr:'CST', offset:'+08:00', label:'China Standard Time' },
  { tz:'Asia/Tokyo', abbr:'JST', offset:'+09:00', label:'Japan Standard Time' },
  { tz:'Asia/Seoul', abbr:'KST', offset:'+09:00', label:'Korea Standard Time' },
  { tz:'Australia/Sydney', abbr:'AEDT/AEST', offset:'+10:00', label:'Australian Eastern Time' },
  { tz:'Pacific/Auckland', abbr:'NZDT/NZST', offset:'+12:00', label:'New Zealand Time' },
  { tz:'Pacific/Honolulu', abbr:'HST', offset:'-10:00', label:'Hawaii Standard Time' },
  { tz:'America/Anchorage', abbr:'AKST/AKDT', offset:'-09:00', label:'Alaska Time' },
  { tz:'America/Los_Angeles', abbr:'PST/PDT', offset:'-08:00', label:'Pacific Time (US)' },
  { tz:'America/Denver', abbr:'MST/MDT', offset:'-07:00', label:'Mountain Time (US)' },
  { tz:'America/Chicago', abbr:'CST/CDT', offset:'-06:00', label:'Central Time (US)' },
  { tz:'America/New_York', abbr:'EST/EDT', offset:'-05:00', label:'Eastern Time (US)' },
  { tz:'America/Sao_Paulo', abbr:'BRT', offset:'-03:00', label:'Brasilia Time' },
  { tz:'America/Argentina/Buenos_Aires', abbr:'ART', offset:'-03:00', label:'Argentina Time' },
];

// Build a representative city entry from a timezone zone
function cityFromZone(zone) {
  // Try to find a matching city
  const match = CITIES.find(c => c.tz === zone.tz);
  if (match) return match;
  // Synthesize a generic entry
  const tzShort = zone.tz.split('/').pop().replace(/_/g,' ');
  return { name: tzShort, country: zone.label, tz: zone.tz, abbr: zone.abbr.split('/')[0] };
}

// Parse "UTC+2", "UTC-5:30" etc into offset hours
function parseUTCOffset(q) {
  const m = q.match(/^utc([+-])(\d{1,2})(?::?(\d{2}))?$/i);
  if (!m) return null;
  const sign = m[1] === '+' ? 1 : -1;
  const h = parseInt(m[2]);
  const min = m[3] ? parseInt(m[3]) : 0;
  return sign * (h * 60 + min); // total offset minutes
}

// ============================================================
// SEARCH
// ============================================================
const input = document.getElementById('citySearch');
const dropdown = document.getElementById('dropdown');

input.addEventListener('input', () => {
  const q = input.value.trim().toLowerCase();
  if (!q) { dropdown.classList.remove('open'); return; }

  dropdown.innerHTML = '';
  let hasResults = false;

  // 1. Check if it's a UTC offset like "UTC+2" or "GMT-5"
  const normQ = q.replace(/^gmt/i,'UTC');
  const offsetMins = parseUTCOffset(normQ);
  if (offsetMins !== null) {
    const matches = TZ_ZONES.filter(z => {
      const [sign, rest] = z.offset[0] === '-' ? [-1, z.offset.slice(1)] : [1, z.offset.slice(1)];
      const [oh, om] = rest.split(':').map(Number);
      return sign * (oh * 60 + (om||0)) === offsetMins;
    });
    if (matches.length) {
      addDropdownSep('Timezones');
      matches.forEach(zone => addTZItem(zone));
      hasResults = true;
    }
  }

  // 2. Search cities by name or country
  const cityResults = CITIES.filter(c =>
    c.name.toLowerCase().includes(q) ||
    c.country.toLowerCase().includes(q)
  ).slice(0, 6);
  if (cityResults.length) {
    addDropdownSep('Cities');
    cityResults.forEach(city => {
      const item = document.createElement('div');
      item.className = 'dropdown-item';
      item.innerHTML = `<span>${city.name}, ${city.country}</span><span class="tz-label">${city.abbr}<span class="tz-type">city</span></span>`;
      item.addEventListener('click', () => {
        if (!cities.find(c => c.name === city.name)) { cities.push(city); render(); }
        input.value = ''; dropdown.classList.remove('open');
      });
      dropdown.appendChild(item);
    });
    hasResults = true;
  }

  // 3. Search timezone zones by abbr, IANA name, or label
  const tzResults = TZ_ZONES.filter(z =>
    z.abbr.toLowerCase().includes(q) ||
    z.tz.toLowerCase().replace(/_/g,' ').includes(q) ||
    z.label.toLowerCase().includes(q) ||
    z.offset.includes(q)
  ).slice(0, 5);
  if (tzResults.length && offsetMins === null) {
    addDropdownSep('Timezones');
    tzResults.forEach(zone => addTZItem(zone));
    hasResults = true;
  }

  if (!hasResults) {
    dropdown.innerHTML = '<div class="dropdown-item"><span style="color:var(--muted)">No results — try a city name, timezone (EET, JST) or UTC offset (UTC+2)</span></div>';
  }
  dropdown.classList.add('open');
});

function addDropdownSep(label) {
  const sep = document.createElement('div');
  sep.className = 'dropdown-sep';
  sep.textContent = label;
  dropdown.appendChild(sep);
}

function addTZItem(zone) {
  const city = cityFromZone(zone);
  const item = document.createElement('div');
  item.className = 'dropdown-item';
  item.innerHTML = `<span>${zone.label} <span style="color:var(--muted);font-size:0.65rem">${zone.tz}</span></span><span class="tz-label">${zone.abbr.split('/')[0]} ${zone.offset}<span class="tz-type tz-zone">tz</span></span>`;
  item.addEventListener('click', () => {
    if (!cities.find(c => c.tz === city.tz && c.name === city.name)) { cities.push(city); render(); }
    input.value = ''; dropdown.classList.remove('open');
  });
  dropdown.appendChild(item);
}

document.addEventListener('click', e => { if (!e.target.closest('.search-wrap')) dropdown.classList.remove('open'); });

// ============================================================
// LIVE CLOCK (when no selection)
// ============================================================
setInterval(() => {
  if (selStart !== null) return;
  cities.forEach((city, idx) => {
    const el = document.getElementById(`rlabel_${idx}`);
    if (el) updateRangeLabelEl(el, idx);
  });
}, 1000);

// ============================================================
// INIT
// ============================================================
buildDateNav();
cities = [
  CITIES.find(c => c.name === 'Bucharest'),
  CITIES.find(c => c.name === 'London'),
  CITIES.find(c => c.name === 'New York'),
  CITIES.find(c => c.name === 'Mumbai'),
  CITIES.find(c => c.name === 'Tokyo'),
];
render();
</script>
</body>
</html>
